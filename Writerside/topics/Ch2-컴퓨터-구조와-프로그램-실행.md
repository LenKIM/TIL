# Ch2 컴퓨터 구조와 프로그램 실행

하드웨어 및 동작에 대한 이해

![image_8.png](image_8.png)

![image_9.png](image_9.png)

메모리라는 것은 CPU의 작업 공간을 의미

CPU 는 매 클럭 순간,

CPU 앞에 있는 Mode bit 는 `사용자 모드` or `운영체제 모드` 임을 선택한다.

CPU가 디스크에 비해 100만배 느리다.

CPU는 항상 메모리와 일한다!
CPU는 계속 메모리에 접근해서 IO에 대한 데이터 구조를 참고한다.
CPU는 IO controller에게 일을 시키고 계속 메모리에 접근하면서 인터럽트를 한다.
인터럽트란 컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법을 말한다.

만약 무한 루프를 실행했을 때, CPU가 하나의 Memory만 계속 참조한다면, 이때 timer가 동작한다.
timer가 한 메모리에 독점하지 않도록 해준다.

운영체제가 CPU를 얻게 되면 어떻게 되겠는가?  - 사용자는 직접 IO를 접근할 수 없다.

### Mode Bit

사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치 필요

**하드웨어적으로 두 가지 모드의 operation 지원**

- 1 사용자 모드 - 사용자 프로그램 수행
- 0 모니터 모드 - OS 코드 수행
  - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 특권명령으로 규정
  - Interrupt나 Execption 발생시 하드웨어가 mode bit을 0으로 바뀜 
  - 사용자 프로그램에서 CPU를 넘기기 전에 mode bit을 1로 셋팅
- 모니터 모드(= 커널 모드, 시스템 모드)

![image_10.png](image_10.png)

### Timer

- 정해진 시간이 흐른 뒤 운영체제에서 제어권이 넘어가도록 인터럽트를 발생함
  - 타이머는 매 클럭 틱 때마다 1씩 감소
  - 타이머 값이 0이 되면 타이머 인터럽트 발생
  - CPU를 특정 프로그램이 독점하는 것으로부터 보호
- 타이머는 time sharing 을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용
- Timer는 Interrupt line을 바라보고 있다. 체크하고 넘기고 체크하고 넘기고

### Device Controller

- I/O device controller
  - 해당 I/O 장치유형을 관리하는 일종의 작은 CPU 
  - 제어 정보를 위해 control register, status register를 가짐 
  - Local buffer를 가짐(일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남 
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

### Device Driver(장치 구동기)

OS 코드 중 각 장치별 처리 루틴 - software

### DeviceController(장치 제어기)

각 장치를 통제하는 일종의 작은 CPU - hardware

### DMA Controller

직접 메모리 접근가능자. Memory controller의 경우 CPU와 DMA controller가 동시에 접근할 경우 중재해준다.
CPU의 보조 역할을 담당한다.

### 입출력(I/O)의 수행
- 모든 입출력 명령은 특권명령
- 사용자 프로그램은 어떻게 I/O를 하는가?
  - 시스템 콜(System Call)
    - 사용자 프로그램은 운영체제에게 I/O 요청
    - 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것
  - TRAP 사용하여 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  - 올바른 I/O 요청인지 확인 후 I/O 수행
  - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### 인터럽트(Interrupt)

- 인터럽트 당한 시점의 레지스터와 program counter를 save한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
- Interrupt(넓은 의미)
  - 하드웨어 인터럽트를 의미한다. 하드웨어가 발생시킨 인터럽트
  - Trap(소프트웨어 인터럽트)
    - Exception - 프로그램이 오류를 범한 경우
    - System call - 프로그램이 커널 함수를 호출하는 경우
  - 인터럽트 관련 용어
    - 인터럽트 벡터
      - 해당 인터럽트의 처리 루틴 주소를 가지고 있음
    - 인터럽트 처리 루틴
      - 해당 인터럽트를 처리하는 커널 함수
  - Interrupt line
    - CPU 옆에 있는 인터럽트 라인(Interrupt line)
    - CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 먼저 처리
    - CPU 명령 하나를 수행할 때마다 인터럽트가 발생했는지 확인

ModeBit 이 0일때만 IO에 접근 가능하다.

Program Counter

System Call

사용자 프로그램이 OS를 점프 할 때, 인터럽트 라인을 확인하고 넘어간다!

### 인터럽트 핸들링(interrupt handling)

인터럽트가 발생한 경우에 처리해야 할 일의 처리를 의미

#### 동기식 입출력(Synchronous I/O)(시간적으로 맞추는 것)

- I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
- 구현방법 1
  - I/O가 끝날 때까지 CPU를 낭비시킴
  - 매 시점 하나의 I/O만 일어날 수 있음
- 구현방법2
  - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세운다.
  - 그 동안 입출력 작업을 수행하는 입출력장치는 봉쇄상태로 전환시킨다고 말한다. 봉쇄상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업을 수행할 수 있는 프로그램에게만 CPU를 할당한다.
  - 그러나 이렇게되면 순서를 보장할 수 없어, 큐에 담아 요청한 순서대로 처리할 수 있도록 한다.
  - 다른 프로그램에게 CPU 사용할 수 있는 권한을 준다.

#### 비동기식 입출력(asynchronous I/O)

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감
- 그 후 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 

=> 두 경우 모두 I/O의 완료를 인터럽트로 알려줌.


#### DMA(Direct Memory Access)

- 원래는 메모리에 접근할수 있는 건 CPU 밖에 없지만, 키보드를 예로 타자 칠때마다 CPU 인터럽션이 발생하는 것이 효율적으로 동작하지 못하기 때문에, DMA Controller가 Memory에 직접접근할 수 있도록 한다.
- I/O에 로컬 버퍼에 있는 데이터 바이트 단위가 아닌 block 단위로 DMA 의해 메모리에 올라가게 되는데, 해당 I/O 데이터 전송이 끝나면 'DMA는 CPU에게 끝났다' 라는 인터럽션을 보낸다. 

#### 서로 다른 입출력 명령어

- I/O를 수행하는 special instruction에 의해
- Memory Mapped I/O에 의해

![image_11.png](image_11.png)

저장 계층 구조

![image_12.png](image_12.png)

**연두색 부분은 휘발성, 주황색은 비휘발성**

CPU 메모리에 접근하려면 바이트단위여야 한다.

그 자리에서 CPU가 바로 접근 가능

'하드 디스크는 섹터 단위로 접근 가능한다'는 의미는 Executable 하지 않다고 한다.

빠른 매체로 정보를 읽어들여 활용하는 것을 캐슁이라고 한다. Main Memory => Cache Memory 이동 할 때.

#### 프로그램의 실행

어떻게 프로그램이 시작되는가????

![image_13.png](image_13.png)

File System 안에 실행파일 A, B(일반적으로 Bin).

실행시키게 되면 메모리안에서 프로세스로 올라가게 된다.

그러나, 정확하게는 중간에 한층을 더 거치게 되는데, 이것은 바로 가상메모리이다.

![image_14.png](image_14.png)

**가상메모리**를 거치게 됩니다. 프로세스 B, 프로세스 A ,메모리 주소 공간을 담습니다.
Stack / Data / Code 로 구성되어 있는 메모리 주소 공간에 담습니다.

**가상메모리는 각 실행파일마다 가지고있는 고유의 메모리 주소 공간이라고 부른다.**

파일 시스템과 Swap Area는 다른 거다. Swap area는 전원이 나가면 의미가 없다.
Why? 물리메모리에 있는 데이터가 없어지면서 Swap area

![image_15.png](image_15.png)

운영 체제 커널도 어떻게 보면 하나의 프로그램이기 때문에 다음과 같은 구조를 가진다.

![image_16.png](image_16.png)

스택에 따로 프로세스 커널 스택을 담아두는 이유는 각각의 프로세스가 스택에 함수를 푸쉬하기 때문에.

![image_17.png](image_17.png)

![image_18.png](image_18.png)

유저모드 커널모드가 변환되는 부분부분을 주의깊게 생각한다.
